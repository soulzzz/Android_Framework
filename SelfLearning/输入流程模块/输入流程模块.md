

# 输入流程



## 一.IMS初始化

![输入流程](.\输入流程.png)



#### 1.1 IMS 初始化

首先是 Zygote 启动 SystemServer 过程中启动了 InputManagerService 和 WindowManagerService 

```
frameworks/base/services/java/com/android/server/SystemServer.java

private void startOtherServices() {
    WindowManagerService wm = null;
    InputManagerService inputManager = null;
    …
   
    inputManager = new InputManagerService(context);
   
    wm = WindowManagerService.main(context, inputManager,
             mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,
             !mFirstBoot, mOnlyCore, new PhoneWindowManager());
    ServiceManager.addService(Context.WINDOW_SERVICE, wm);
    ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
    …
    
   	// 设置向WMS发起回调的callback对象
    inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
    inputManager.start();
   
}

```

InputManagerService 的构造方法中执行了JNI调用方法 nativeInit ，成功创建了一个 NativeInputManager 实例。

```
frameworks/base/services/core/java/com/android/server/input/InputManagerService.java

public InputManagerService(Context context) {
    this.mContext = context;
    //IMS中的消息队列处理都是在单独的DisplayThread中进行的
    //运行在SystemServer里的单例线程 只给WindowManager, DisplayManager,InputManager 使用
    this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper());
    …
    mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue());
    …
}



frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

static jlong nativeInit(JNIEnv* env, jclass /* clazz */,
        jobject serviceObj, jobject contextObj, jobject messageQueueObj) {
   sp<MessageQueue> messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
   if (messageQueue == NULL) {
        jniThrowRuntimeException(env, "MessageQueue is not initialized.");
        return 0;
    }
    NativeInputManager* im = new NativeInputManager(contextObj, serviceObj,
            messageQueue->getLooper());
    im->incStrong(0);
    return reinterpret_cast<jlong>(im);
}
```

在 NativeInputManager 的初始化中创建了一个Eventhub (将数据从硬件驱动上读出来然后传递上来的通道) ，同时将这个Eventhub 传给新建的 Inputmanager。

```
frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

NativeInputManager::NativeInputManager(jobject contextObj,
        jobject serviceObj, const sp<Looper>& looper) :
        mLooper(looper), mInteractive(true) {
    …
    //构造一个EventHub对象,最原始的输入事件都是通过它收集并且传RawEvent到InputReader对象
    sp<EventHub> eventHub = new EventHub();
    mInputManager = new InputManager(eventHub, this, this);
}
```

InputManager初始化时创建了两个重要操作类：InputReader （用于获取Eventhub的事件并处理和转发) 和 InputDispatcher。

```
frameworks/native/services/inputflinger/InputManager.cpp

InputManager::InputManager(
        const sp<EventHubInterface>& eventHub,
        const sp<InputReaderPolicyInterface>& readerPolicy,
        const sp<InputDispatcherPolicyInterface>& dispatcherPolicy) {
    mDispatcher = new InputDispatcher(dispatcherPolicy);
    //把mDispatcher 当参数传了进去 用于后续把事件传递给它 mQueuedListener.flush();
    mReader = new InputReader(eventHub, readerPolicy, mDispatcher);
    initialize();
}


void InputManager::initialize() {
	// 创建供InputReader运行的线程InputReaderThread
    mReaderThread = new InputReaderThread(mReader);
    // 创建供InputDispatcher运行的线程InputDispatcherThread
    mDispatcherThread = new InputDispatcherThread(mDispatcher);
}
```

#### 1.2 IMS 启动

```
frameworks/base/services/core/java/com/android/server/input/InputManagerService.java

public void start() {
    Slog.i(TAG, "Starting input manager");
    nativeStart(mPtr);
    ...
}
```



```
frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

static void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) {
	NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);

	status_t result = im->getInputManager()->start();
}
```

进入native层InputManager的start函数

```
frameworks/native/services/inputflinger/InputManager.cpp

status_t InputManager::start() {

    status_t result = mDispatcherThread->run("InputDispatcher", PRIORITY_URGENT_DISPLAY);
    if (result) {
        ALOGE("Could not start InputDispatcher thread due to error %d.", result);
        return result;
    }

    result = mReaderThread->run("InputReader", PRIORITY_URGENT_DISPLAY);
    if (result) {
        ALOGE("Could not start InputReader thread due to error %d.", result);
        mDispatcherThread->requestExit();
        return result;
    }

    return OK;
}
```

调用它们的run方法后，就会进入threadLoop函数中，只要threadLoop函数返回true，该函数就会循环执行。

```
frameworks/native/services/inputflinger/InputReader.cpp

bool InputReaderThread::threadLoop() {
	mReader->loopOnce();
	return true;
}

bool InputDispatcherThread::threadLoop() {
   mDispatcher->dispatchOnce();//开始处理分发
   return true;
}
```

#### 1.3 IMS获取 处理 传递事件

```
frameworks/native/services/inputflinger/InputReader.cpp

void InputReader::loopOnce() {
   …
   // 获取事件
   // 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数
   // 当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时  
   // static const int EVENT_BUFFER_SIZE = 256;
   // RawEvent mEventBuffer[EVENT_BUFFER_SIZE];
   
   size_t count = mEventHub->getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);
   { // acquire lock
       AutoMutex _l(mLock);
       mReaderIsAliveCondition.broadcast();
       if (count) {
           //处理事件 把RawEvent转化为NotifyArgs给Dispatcher
           processEventsLocked(mEventBuffer, count);
       }
   …
   //传递事件
   mQueuedListener->flush();
}


```

##### 1.3.1 InputReader 处理事件

```
frameworks/native/services/inputflinger/InputReader.cpp

void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) {
   for (const RawEvent* rawEvent = rawEvents; count;) {
       int32_t type = rawEvent->type;
       size_t batchSize = 1;
       if (type < EventHubInterface::FIRST_SYNTHETIC_EVENT) {
           int32_t deviceId = rawEvent->deviceId;
           while (batchSize < count) {
               if (rawEvent[batchSize].type >= EventHubInterface::FIRST_SYNTHETIC_EVENT
                       || rawEvent[batchSize].deviceId != deviceId) {
                   break;
               }
               batchSize += 1;
           }
           //1、处理输入事件
           processEventsForDeviceLocked(deviceId, rawEvent, batchSize);
       } else {
           switch (rawEvent->type) {
           case EventHubInterface::DEVICE_ADDED://2、添加输入设备  给每个设备添加上对应的Mapper
               addDeviceLocked(rawEvent->when, rawEvent->deviceId);
               break;
           case EventHubInterface::DEVICE_REMOVED://3、删除输入设备
               removeDeviceLocked(rawEvent->when, rawEvent->deviceId);
               break;
           case EventHubInterface::FINISHED_DEVICE_SCAN://4、完成设备扫描
               handleConfigurationChangedLocked(rawEvent->when);
               break;
           default:
               ALOG_ASSERT(false); // can't happen
               break;
           }
       }
       count -= batchSize;
       rawEvent += batchSize;
   }
}
```

到处理输入事件的方法中

```
frameworks/native/services/inputflinger/InputReader.cpp

void InputReader::processEventsForDeviceLocked(int32_t deviceId,
        const RawEvent* rawEvents, size_t count) {
    ssize_t deviceIndex = mDevices.indexOfKey(deviceId);
    if (deviceIndex < 0) {
        ALOGW("Discarding event for unknown deviceId %d.", deviceId);
        return;
    }
	//获取到对应的device
    InputDevice* device = mDevices.valueAt(deviceIndex);
    if (device->isIgnored()) {
        //ALOGD("Discarding event for ignored deviceId %d.", deviceId);
        return;
    }
	//device执行process操作
    device->process(rawEvents, count);
}
```

进入对应的device处理操作

```
void InputDevice::process(const RawEvent* rawEvents, size_t count) {
   size_t numMappers = mMappers.size();
    for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++) {
     ...
       if (mDropUntilNextSync) {
          ...
        } else if (rawEvent->type == EV_SYN && rawEvent->code == SYN_DROPPED) {
            ALOGI("Detected input event buffer overrun for device %s.", getName().string());
            mDropUntilNextSync = true;
            reset(rawEvent->when);
        } else {//对应的EV_KEY type走如下流程
            for (size_t i = 0; i < numMappers; i++) {
                InputMapper* mapper = mMappers[i];
                mapper->process(rawEvent);//对应的InputMapper执行process操作
            }
        }
    }
}
```

由相应的实现类mapper处理操作

```
frameworks/native/services/inputflinger/InputReader.cpp

void KeyboardInputMapper::process(const RawEvent* rawEvent) {
    switch (rawEvent->type) {
    //按键事件
    case EV_KEY: {
        int32_t scanCode = rawEvent->code;
        int32_t usageCode = mCurrentHidUsage;
        mCurrentHidUsage = 0;
        if (isKeyboardOrGamepadKey(scanCode)) {
            processKey(rawEvent->when, rawEvent->value != 0, scanCode, usageCode);
        }
        break;
    }
    //其他事件
    case EV_MSC: {
        if (rawEvent->code == MSC_SCAN) {
            mCurrentHidUsage = rawEvent->value;
        }
        break;
    }
    //同步事件
    case EV_SYN: {
        if (rawEvent->code == SYN_REPORT) {
            mCurrentHidUsage = 0;
        }
    }
    }
}
```

这里以案件事件EV_KEY按键事件为例，这里会执行processKey方法

```
frameworks/native/services/inputflinger/InputReader.cpp

void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t scanCode,
        int32_t usageCode) {
    int32_t keyCode;
    int32_t keyMetaState;
    uint32_t policyFlags;
 	//调用eventhub的mapKey
 	//获取所对应的KeyCode
    if (getEventHub()->mapKey(getDeviceId(), scanCode, usageCode, mMetaState,
                              &keyCode, &keyMetaState, &policyFlags)) {
        keyCode = AKEYCODE_UNKNOWN;
        keyMetaState = mMetaState;
        policyFlags = 0;
    }

    if (down) {
        // Rotate key codes according to orientation if needed.
        if (mParameters.orientationAware && mParameters.hasAssociatedDisplay) {
            keyCode = rotateKeyCode(keyCode, mOrientation);
        }

        // Add key down.
        ssize_t keyDownIndex = findKeyDown(scanCode);
        if (keyDownIndex >= 0) {
            // key repeat, be sure to use same keycode as before in case of rotation
            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;
        } else {
            // key down
            if ((policyFlags & POLICY_FLAG_VIRTUAL)
                    && mContext->shouldDropVirtualKey(when,
                            getDevice(), keyCode, scanCode)) {
                return;
            }
            if (policyFlags & POLICY_FLAG_GESTURE) {
                mDevice->cancelTouch(when);
            }

            mKeyDowns.push();
            KeyDown& keyDown = mKeyDowns.editTop();
            keyDown.keyCode = keyCode;
            keyDown.scanCode = scanCode;
        }

        mDownTime = when;
    } else {
        // Remove key down.
        ssize_t keyDownIndex = findKeyDown(scanCode);
        if (keyDownIndex >= 0) {
            // key up, be sure to use same keycode as before in case of rotation
            keyCode = mKeyDowns.itemAt(keyDownIndex).keyCode;
            mKeyDowns.removeAt(size_t(keyDownIndex));
        } else {
            // key was not actually down
            ALOGI("Dropping key up from device %s because the key was not down.  "
                    "keyCode=%d, scanCode=%d",
                    getDeviceName().string(), keyCode, scanCode);
            return;
        }
    }

    if (updateMetaStateIfNeeded(keyCode, down)) {
        // If global meta state changed send it along with the key.
        // If it has not changed then we'll use what keymap gave us,
        // since key replacement logic might temporarily reset a few
        // meta bits for given key.
        keyMetaState = mMetaState;
    }

    nsecs_t downTime = mDownTime;

    // Key down on external an keyboard should wake the device.
    // We don't do this for internal keyboards to prevent them from waking up in your pocket.
    // For internal keyboards, the key layout file should specify the policy flags for
    // each wake key individually.
    // TODO: Use the input device configuration to control this behavior more finely.
    if (down && getDevice()->isExternal() && !isMediaKey(keyCode)) {
        policyFlags |= POLICY_FLAG_WAKE;
    }

    if (mParameters.handlesKeyRepeat) {
        policyFlags |= POLICY_FLAG_DISABLE_KEY_REPEAT;
    }

    NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,
            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,
            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, keyMetaState, downTime);
    //参数打包成args发送给Listener
    //上面所作的一切都是RawEvent ——> NotifyArgs 转化
    getListener()->notifyKey(&args);
}
```

最终将event组合成了一个notifykeyArgs数据结构，同时调用了listener的notifykey方法。

```
frameworks/native/services/inputflinger/InputListener.cpp

void QueuedInputListener::notifyKey(const NotifyKeyArgs* args) {
    mArgsQueue.push(new NotifyKeyArgs(*args));
}
```

把事件放入mArgsQueue容器中，然后就是把事件发送给InputDispatcher线程了

![NotifyArgs](.\NotifyArgs.png)

​																									NotifyArgs及子类

##### 1.3.2 InputDispatcher 得到 传递事件

```
frameworks/native/services/inputflinger/InputListener.cpp

void QueuedInputListener::flush() {
    size_t count = mArgsQueue.size();
    for (size_t i = 0; i < count; i++) {
    NotifyArgs* args = mArgsQueue[i];
    //mInnerListener实际就是InputDispatcher
    args->notify(mInnerListener);
    delete args;
    }
    mArgsQueue.clear();
}
```

从ArgsQueue把事件取出来，分别调用它们自己的notify方法

以NotifyKeyArgs为例：

```
frameworks/native/services/inputflinger/InputListener.cpp

void NotifyKeyArgs::notify(const sp<InputListenerInterface>& listener) const {
	//listener实际就是InputDispatcher
    listener->notifyKey(this);
}
```

notifyKey()就是InputDispacher的成员函数



##### 1.3.3 InputDisPatcher处理事件

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::notifyKey(const NotifyKeyArgs* args) {
    ... 
    int32_t keyCode = args->keyCode;
    ...
    //会先把  NotifyKeyArgs 转化为 KeyEvent
    //父类分别为 NotifyArgs  和   InputEvent   
   	// InputEvent 的两个实现类为 KeyEvent 和 MotionEvent
    KeyEvent event;
    event.initialize(args->deviceId, args->source, args->action, flags, keyCode, args->scanCode, metaState, 0, args->downTime, args->eventTime); 
  ...
  //mPolicy是指 NativeInputManager 对象 对事件进行第一次拦截
  mPolicy->interceptKeyBeforeQueueing(&event, /*byref*/ policyFlags);
  bool needWake;
    	{ // acquire lock
        	mLock.lock();
        if (shouldSendKeyToInputFilterLocked(args)) {
            mLock.unlock();
            policyFlags |= POLICY_FLAG_FILTERED;
            //过滤一些按键
            if (!mPolicy->filterInputEvent(&event, policyFlags)) {
                return; // event was consumed by the filter
            }
            mLock.lock();
        }
        int32_t repeatCount = 0;
        // KeyEntry 
        // 父类为EventEntry 其同类类似地有MotionEntry
        // 将 拦截后的结果处理 转化为KeyEntry 后进入分发队列 mInboundQueue
        KeyEntry* newEntry = new KeyEntry(args->eventTime,
                args->deviceId, args->source, policyFlags,
                args->action, flags, keyCode, args->scanCode,
                metaState, repeatCount, args->downTime);
		//将 KeyEntry 压入队列mInboundQueue
        needWake = enqueueInboundEventLocked(newEntry);
        mLock.unlock();
    } // release lock

    if (needWake) {
        mLooper->wake();
    }
}
```

 进行拦截 方法调用为

1 NativeInputManager.interceptKeyBeforeQueueing，加入队列前执行拦截动作，但并不改变流程
	2 IMS.interceptKeyBeforeQueueing
		3 InputMonitor.interceptKeyBeforeQueueing（继承IMS.WindowManagerCallbacks）
			4 PhoneWindowManager.interceptKeyBeforeQueueing（继承WindowManagerPolicy）



进入1拦截的方法

```
frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

void NativeInputManager::interceptKeyBeforeQueueing(const KeyEvent* keyEvent,
        uint32_t& policyFlags) {
    ATRACE_CALL();

    bool interactive = mInteractive.load();
    if (interactive) {
        policyFlags |= POLICY_FLAG_INTERACTIVE;
    }
    if ((policyFlags & POLICY_FLAG_TRUSTED)) {
        nsecs_t when = keyEvent->getEventTime();
        JNIEnv* env = jniEnv();
        jobject keyEventObj = android_view_KeyEvent_fromNative(env, keyEvent);
        jint wmActions;
        if (keyEventObj) { //通过JNI方法回调JAVA层
            wmActions = env->CallIntMethod(mServiceObj,
                    gServiceClassInfo.interceptKeyBeforeQueueing,
                    keyEventObj, policyFlags);
            if (checkAndClearExceptionFromCallback(env, "interceptKeyBeforeQueueing")) {
                wmActions = 0;
            }
            android_view_KeyEvent_recycle(env, keyEventObj);
            env->DeleteLocalRef(keyEventObj);
        } else {
            ALOGE("Failed to obtain key event object for interceptKeyBeforeQueueing.");
            wmActions = 0;
        }

        handleInterceptActions(wmActions, when, /*byref*/ policyFlags);
    } else {
        if (interactive) {
            policyFlags |= POLICY_FLAG_PASS_TO_USER;
        }
    }
}
```

 2 通过Jni调用上层 interceptKeyBeforeQueueing 

```
frameworks/base/services/core/java/com/android/server/input/InputManagerService.java

    private int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    	//mWindowManagerCallbacks 实际就是IMS初始化后WM传入的 wm.getInputMonitor()
        return mWindowManagerCallbacks.interceptKeyBeforeQueueing(event, policyFlags);
    }
```

3 进入InputMonitor的拦截方法

```
frameworks/base/services/core/java/com/android/server/input/InputManagerService.java

    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    	//mPolicy 是 WindowManagerPolicy 接口 其实现类为PhoneWindowManager
        return mService.mPolicy.interceptKeyBeforeQueueing(event, policyFlags);
    }
```

4 进入 PhoneWindowManager的拦截方法 

```
frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java

    public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
        if (!mSystemBooted) {
            // If we have not yet booted, don't let key events do anything.
            return 0;
        }
        //处理很多按键 
        .... 
        
        return result;
        //返回0则意味着事件被拦截，返回1则意味着事件允许被发送到应用程序中
        //返回值保存在wmActions变量中
    }
    
```

然后调用handleInterceptActions方法处理返回值。其定义如下

```
frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

void NativeInputManager::handleInterceptActions(jint wmActions, nsecs_t when,
        uint32_t& policyFlags) {
    if (wmActions & WM_ACTION_PASS_TO_USER) {
        policyFlags |= POLICY_FLAG_PASS_TO_USER;
    } else {
#if DEBUG_INPUT_DISPATCHER_POLICY
        ALOGD("handleInterceptActions: Not passing key to user.");
#endif
    }
}



WM_ACTION_PASS_TO_USER定义如下：
enum {
    WM_ACTION_PASS_TO_USER = 1,
};
```

这里位运算，但结果就是如果返回值为1，二者位与后为1，则给policyFlags 添加POLICY_FLAG_PASS_TO_USER标志，意味着可以把该事件发送到应用程序，反之不行。



#### 1.4 InputDispatcher 分发事件

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

bool InputDispatcherThread::threadLoop() {
   mDispatcher->dispatchOnce();//开始处理分发
   return true;
}


void InputDispatcher::dispatchOnce() {
    nsecs_t nextWakeupTime = LONG_LONG_MAX;
    { // acquire lock
        AutoMutex _l(mLock);
        mDispatcherIsAliveCondition.broadcast();
        ///优先处理Command 例如ANR 唤醒屏幕 分发完成移除事件等
        if (!haveCommandsLocked()) {
            //没有等待的命令，将输入事件分发给合适的window
            dispatchOnceInnerLocked(&nextWakeupTime);
        }

        if (runCommandsLockedInterruptible()) {
        	// 处理完Command，立即唤醒loop来处理input event
            nextWakeupTime = LONG_LONG_MIN;
        }
    } // release lock
      //获取当前时间
    nsecs_t currentTime = now();
        //获取睡眠的时间
    int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);
         //InputDispatchThread进入睡眠状态
    mLooper->pollOnce(timeoutMillis);
}

```

这里的Command保存在mCommandQueue中，主要有

doPokeUserActivityLockedInterruptible
doNotifyANRLockedInterruptible
doInterceptKeyBeforeDispatchingLockedInterruptible
doDispatchCycleFinishedLockedInterruptible
doNotifyInputChannelBrokenLockedInterruptible
doNotifyConfigurationChangedInterruptible

最终这些命令会回调JAVA层IMS处理

dispatchOnceInnerLocked函数处理进行事件分发

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) {
    nsecs_t currentTime = now();
     ...
        done = dispatchKeyLocked(currentTime, typedEntry, &dropReason, nextWakeupTime);
        break;
    }
    ...
    }

    if (done) {
        if (dropReason != DROP_REASON_NOT_DROPPED) {
            dropInboundEventLocked(mPendingEvent, dropReason);
        }
        mLastDropReason = dropReason;
         //释放本次事件处理的对象
        releasePendingEventLocked();
            //让InputDispatcher快速处理下一个请求
        *nextWakeupTime = LONG_LONG_MIN;  // force next poll to wake up immediately
    }
}

```

进入dispatchKeyLocked 事件分发方法:

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry,
        DropReason* dropReason, nsecs_t* nextWakeupTime) {
          ...
          Vector<InputTarget> inputTargets;
          //寻找焦点窗口 将它放到inputTargets里面
          int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,
                  entry, inputTargets, nextWakeupTime);
          ...


          dispatchEventLocked(currentTime, entry, inputTargets);
}

```

##### 1.4.1 寻找焦点窗口

进入 findFocusedWindowTargetsLocked 方法 这是寻找焦点窗口的方法

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

int32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime,
        const EventEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime) {
    ...

    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;
    addWindowTargetLocked(mFocusedWindowHandle,
            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(0),
            inputTargets);
    ...
    return injectionResult;
}

void InputDispatcher::addWindowTargetLocked(const sp<InputWindowHandle>& windowHandle,
        int32_t targetFlags, BitSet32 pointerIds, Vector<InputTarget>& inputTargets) {
    inputTargets.push();

    const InputWindowInfo* windowInfo = windowHandle->getInfo();
    InputTarget& target = inputTargets.editTop();
    target.inputChannel = windowInfo->inputChannel;
    target.flags = targetFlags;
    target.xOffset = - windowInfo->frameLeft;
    target.yOffset = - windowInfo->frameTop;
    target.scaleFactor = windowInfo->scaleFactor;
    target.pointerIds = pointerIds;
}

```



##### 1.4.2 分发事件

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::dispatchEventLocked(nsecs_t currentTime,
        EventEntry* eventEntry, const Vector<InputTarget>& inputTargets) {
#if DEBUG_DISPATCH_CYCLE
    ALOGD("dispatchEventToCurrentInputTargets");
#endif
   ALOG_ASSERT(eventEntry->dispatchInProgress); // should already have been set to true
   //调用到Java层的PowerManagerService.java中的userActivityFromNative()方法． 
   pokeUserActivityLocked(eventEntry);
    for (size_t i = 0; i < inputTargets.size(); i++) {
        const InputTarget& inputTarget = inputTargets.itemAt(i);
       //根据inputChannel的fd从mConnectionsByFd队列中查询目标connection.
        ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);
        if (connectionIndex >= 0) {
        	//connection 封装了inputchannel 
            sp<Connection> connection = mConnectionsByFd.valueAt(connectionIndex);
            //找到目标连接
            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &inputTarget);
        } else {
#if DEBUG_FOCUS
            ALOGD("Dropping event delivery to target with channel '%s' because it "
                   "is no longer registered with the input dispatcher.",
                    inputTarget.inputChannel->getName().string());
#endif
       }
    }
}
```

进入prepareDispatchCycleLocked 方法

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime,
       const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget) {
 ...
   enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);
}

void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget) {
   bool wasEmpty = connection->outboundQueue.isEmpty();
   ...
   enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_IS);
   ...
   if (wasEmpty && !connection->outboundQueue.isEmpty()) {
       startDispatchCycleLocked(currentTime, connection);
   }
}

void InputDispatcher::enqueueDispatchEntryLocked(const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,  int32_t dispatchMode) {
   int32_t inputTargetFlags = inputTarget->flags;
   if (!(inputTargetFlags & dispatchMode)) {
       return;
   }
   //转为 dispatchEntry结构
   //这里又转了一次数据结构，生成新的事件, 加入connection的outbound队列。
   DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset, inputTarget->scaleFactor);
   switch (eventEntry->type) {
   case EventEntry::TYPE_KEY: {
       KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);
       dispatchEntry->resolvedAction = keyEntry->action;
       dispatchEntry->resolvedFlags = keyEntry->flags;
       break;
   }

   //添加到outboundQueue队尾
   connection->outboundQueue.enqueueAtTail(dispatchEntry);
}

```

上面其实等于由做了一次搬运的工作,将InputDispatcher中mInboundQueue中的 eventEntry 事件取出后, 找到目标window后,将eventEntry封装dispatchEntry加入到connection的 outboundQueue 队列。

进入 startDispatchCycleLocked 方法

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp<Connection>& connection) {
   while (connection->status == Connection::STATUS_NORMAL && !connection->outboundQueue.isEmpty()) {
       DispatchEntry* dispatchEntry = connection->outboundQueue.head;
       dispatchEntry->deliveryTime = currentTime;
       // Publish the event.
       status_t status;
       EventEntry* eventEntry = dispatchEntry->eventEntry;
       switch (eventEntry->type) {
       case EventEntry::TYPE_KEY: {
           KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);
           status = connection->inputPublisher.publishKeyEvent(dispatchEntry->seq,
                   keyEntry->deviceId, keyEntry->source,
                   dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags,
                   keyEntry->keyCode, keyEntry->scanCode,
                   keyEntry->metaState, keyEntry->repeatCount, keyEntry->downTime,
                   keyEntry->eventTime);
           break;
       }
       ...
       }
       // Re-enqueue the event on the wait queue.
       connection->outboundQueue.dequeue(dispatchEntry);
       connection->waitQueue.enqueueAtTail(dispatchEntry);
    }
```

通过 InputPublisher 将DispatchEntry发送给窗口，再将DispatchEntry从 outboundQueue 移到 waitQueue 里。当窗口处理完事件后会通过handleReceiveCallback()回调函数通知InputDispatcher。

```
xref/frameworks/native/libs/input/InputTransport.cpp

status_t InputPublisher::publishKeyEvent(...) {
   if (!seq) {
       return BAD_VALUE;
   }
   InputMessage msg;
   msg.header.type = InputMessage::TYPE_KEY;
   msg.body.key.seq = seq;
   msg.body.key.deviceId = deviceId;
   msg.body.key.source = source;
   msg.body.key.action = action;
   msg.body.key.flags = flags;
   msg.body.key.keyCode = keyCode;
   msg.body.key.scanCode = scanCode;
   msg.body.key.metaState = metaState;
   msg.body.key.repeatCount = repeatCount;
   msg.body.key.downTime = downTime;
   msg.body.key.eventTime = eventTime;
   //通过InputChannel来发送消息
   return mChannel->sendMessage(&msg);
}
```

publishKeyEvent 调用InputChanel的SendMessage()，SendMessage()再动用socket的send()函数，将打包好的Message发送给窗口。



##### 1.4.3 回调处理 

```
frameworks/native/services/inputflinger/InputDispatcher.cpp
int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) {
    InputDispatcher* d = static_cast<InputDispatcher*>(data); 
    ssize_t connectionIndex = d->mConnectionsByFd.indexOfKey(fd); 
    sp<Connection> connection = d->mConnectionsByFd.valueAt(connectionIndex);
    if (!(events & (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) {
        nsecs_t currentTime = now();
        bool gotOne = false;
        status_t status;
        for (;;) {
            uint32_t seq;
            bool handled;
            //接收窗口处理完成的消息
            status = connection->inputPublisher.receiveFinishedSignal(&seq, &handled);
            if (status) { // 读完socket即返回WOULD_BLOCK
                break;
            }
            // 这里post一个command
            d->finishDispatchCycleLocked(currentTime, connection, seq, handled);
            gotOne = true;
        }
        if (gotOne) {
            // 这里执行command的handle
            d->runCommandsLockedInterruptible();
            if (status == WOULD_BLOCK) {  // 正常流程走这里
                return 1;
            }
        }
    }
    // 这里是socket链接出现异常的情况
    d->unregisterInputChannelLocked(connection->inputChannel, notify);
    return 0; // remove the callback
}
```

处理Command

```
frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::finishDispatchCycleLocked(nsecs_t currentTime, const sp<Connection>& connection, uint32_t seq, bool handled) {
   ...
   onDispatchCycleFinishedLocked(currentTime, connection, seq, handled);
}
void InputDispatcher::onDispatchCycleFinishedLocked(nsecs_t currentTime, const sp<Connection>& connection, uint32_t seq, bool handled) {
   CommandEntry* commandEntry = postCommandLocked( & InputDispatcher::doDispatchCycleFinishedLockedInterruptible);
   commandEntry->connection = connection;
   commandEntry->eventTime = currentTime;
   commandEntry->seq = seq;
   commandEntry->handled = handled;
}

frameworks/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::doDispatchCycleFinishedLockedInterruptible(CommandEntry* commandEntry) {
   sp<Connection> connection = commandEntry->connection;
   nsecs_t finishTime = commandEntry->eventTime;
   uint32_t seq = commandEntry->seq;
   bool handled = commandEntry->handled;
  // Handle post-event policy actions.
   DispatchEntry* dispatchEntry = connection->findWaitQueueEntry(seq);
   ...
       if (dispatchEntry == connection->findWaitQueueEntry(seq)) {
           // 从waitQueue中将当前entry移除
           connection->waitQueue.dequeue(dispatchEntry);
           traceWaitQueueLengthLocked(connection);
           if (restartEvent && connection->status == Connection::STATUS_NORMAL) {
               connection->outboundQueue.enqueueAtHead(dispatchEntry);
               traceOutboundQueueLengthLocked(connection);
           } else {
              // 释放内存
               releaseDispatchEntryLocked(dispatchEntry);
           }
       }
      // 如果当前connection的outBoundQueque里还有Event，则继续下一轮的Dispatch周期
       startDispatchCycleLocked(now(), connection);
   }
}
```





## 二.Event初始化

```
frameworks/native/services/inputflinger/EventHub.cpp

EventHub::EventHub(void) :
        mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(),
        mOpeningDevices(0), mClosingDevices(0),
        mNeedToSendFinishedDeviceScan(false),
        mNeedToReopenDevices(false), mNeedToScanDevices(true),
        mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(false) {
    acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);
    //创建epoll对象用于监听是否有可读事件,EPOLL_SIZE_HINT为最大监听个数：8
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, "Could not create epoll instance.  errno=%d", errno);
    //创建inotify对象用于监听设备节点DEVICE_PATH，即/dev/input，是否有变化（设备增删），设备的增删对应着设备节点的文件增删
    mINotifyFd = inotify_init();
    //inotify 监听 /dev/input 目录
    int result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);
    LOG_ALWAYS_FATAL_IF(result < 0, "Could not register INotify for %s.  errno=%d",
            DEVICE_PATH, errno);
    struct epoll_event eventItem;
    memset(&eventItem, 0, sizeof(eventItem));
    eventItem.events = EPOLLIN;
    eventItem.data.u32 = EPOLL_ID_INOTIFY;
    //将inotify对象注册到epoll中监听是否有新的可读的设备增删事件
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not add INotify to epoll instance.  errno=%d", errno);
    int wakeFds[2];
    
  	//创建管道，并将读端交给epoll，写端交给InputReader，用于唤醒epoll，避免epoll阻塞在epoll_wait()
	//因为InputReader在执行eventHub.getEvents()时会因无事件而导致其线程阻塞在epoll_wait()的调用里
	//而有时希望能够立刻唤醒InputReader线程使其处理一些请求
	//这时只需向wakeFds管道的写入端写入任意数据，此时读取端有数据可读，使得epoll_wait()得以返回
	//从而达到唤醒InputReader线程的目的
    result = pipe(wakeFds);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);
    mWakeReadPipeFd = wakeFds[0];
    mWakeWritePipeFd = wakeFds[1];
    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
            errno);
    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
            errno);
    eventItem.data.u32 = EPOLL_ID_WAKE;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &eventItem);
    LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
            errno);
    int major, minor;
    getLinuxRelease(&major, &minor);
    // EPOLLWAKEUP was introduced in kernel 3.5
   mUsingEpollWakeup = major > 3 || (major == 3 && minor >= 5);
}
```

#### 2.1 Event获取事件

返回给InputReader的 RawEvent 结构

```
 EventHub.h –> RawEvent 
struct RawEvent {
    nsecs_t when;             /* 发生事件时的时间戳 */
    int32_t deviceId;        //产生事件的设备Id，它是由EventHub自行分配的，InputReader
                            //以根据它从EventHub中获取此设备的详细信息
    int32_t type;             /* 事件的类型  DEVICE_ADD、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN */
    int32_t code;             /* 事件代码 */
    int32_t value;            /* 事件值 */
    };

```

处理过程中的 epoll_event 和input_event结构 

```
//联合体：多种类型是为了考虑后期的拓展
typedef union epoll_data {
    void *ptr;
    int fd;//存放文件描述符
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;

//epoll事件
struct epoll_event {
    __uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
};

struct input_event {

      struct timeval time;

      __u16 type;    //上报类型 EV_SYN: 同步事件  EV_KEY：键盘事件   EV_REL: 相对坐标事件-鼠标    EV_ABS： 绝对坐标事件-触摸屏

      __u16 code;  //type = EV_KEY时，code代表键盘以及鼠标上不同的按键，如code = 9，表示此时event上报的是键盘上数字“9”对应的事件；
      			  //type = EV_REL时，code代表轨迹的类型，指示鼠标移动的方向，如code = 3，表示此时event上报的是鼠标向X轴移动的数据

      __s32 value; //type = EV_KEY，code = 9， value = 0：表示键盘上数字”9“被放开
				 //type = EV_KEY，code = 9， value = 1：表示键盘上数字”9“被按下

};
```



获取事件整体概括:

第一次getEvents时，打开"/dev/input/"目录下的input设备，并将其注册到epoll的监控队列中。这样一旦对应设备上有可读的input事件，则epool_wait()就会返回，并带回deviceid，找到具体的device。整个事件的获取中，除了input事件，设备的打开关闭等信息，也要包装成event，上报给InputReader。简单理解，EventHub就是InputReader用于打开和关闭Input设备，监听和读取Input事件的对象。

```
size_t EventHub::getEvents(int timeoutMillis, RawEvent* buffer, size_t bufferSize) {
   ALOG_ASSERT(bufferSize >= 1);
   AutoMutex _l(mLock);
   struct input_event readBuffer[bufferSize];
   RawEvent* event = buffer;
   size_t capacity = bufferSize;
   bool awoken = false;
   // 接下来的循环是getEvents()函数的主体。在这个循环中，会先将可用事件放入到buffer中并返回。
   // 如果没有可用事件，则进入epoll_wait()等待事件的到来，epoll_wait()返回后会重新循环将可用
   // 将新事件放入 buffer
   for (;;) {
       nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
       // Reopen input devices if needed.
       if (mNeedToReopenDevices) {
           mNeedToReopenDevices = false;
           ALOGI("Reopening all input devices due to a configuration change.");
           closeAllDevicesLocked();
           mNeedToScanDevices = true;
           break; // return to the caller before we actually rescan
       }
       // Report any devices that had last been added/removed.
       // mClosingDevices 在在构造函数中初始值为0，所以此时是没有设备添加和删除的
       while (mClosingDevices) {
           Device* device = mClosingDevices;
           ALOGV("Reporting device closed: id=%d, name=%s\n",
                device->id, device->path.string());
           mClosingDevices = device->next;
           event->when = now;
           event->deviceId = device->id == mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device->id;
           event->type = DEVICE_REMOVED;
           event += 1;
           delete device;
           mNeedToSendFinishedDeviceScan = true;
           if (--capacity == 0) {
               break;
           }
       }
       //第一次为true
       if (mNeedToScanDevices) {
           mNeedToScanDevices = false;
           //打开"/dev/input/"目录下的input设备后，将其注册到epoll的监控队列中。
           scanDevicesLocked();
           mNeedToSendFinishedDeviceScan = true;
       }
       //mOpeningDevices初始化为0,通过scanDevicesLocked()后不为NULL
       while (mOpeningDevices != NULL) {
           Device* device = mOpeningDevices;
           ALOGV("Reporting device opened: id=%d, name=%s\n",
                device->id, device->path.string());
           mOpeningDevices = device->next;
           event->when = now;
           event->deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;
           event->type = DEVICE_ADDED;
           event += 1;
           mNeedToSendFinishedDeviceScan = true;
           if (--capacity == 0) {
               break;
           }
       }
       if (mNeedToSendFinishedDeviceScan) {
           mNeedToSendFinishedDeviceScan = false;
           event->when = now;
           event->type = FINISHED_DEVICE_SCAN;
           event += 1;
           if (--capacity == 0) {
               break;
           }
       }
       // Grab the next input event.
       bool deviceChanged = false;
       while (mPendingEventIndex < mPendingEventCount) {
           const struct epoll_event& eventItem = mPendingEventItems[mPendingEventIndex++];
           if (eventItem.data.u32 == EPOLL_ID_INOTIFY) {
               if (eventItem.events & EPOLLIN) {
                   mPendingINotify = true;
               } else {
                   ALOGW("Received unexpected epoll event 0x%08x for INotify.", eventItem.events);
               }
               continue;
           }
           if (eventItem.data.u32 == EPOLL_ID_WAKE) {
               if (eventItem.events & EPOLLIN) {
                   ALOGV("awoken after wake()");
                   awoken = true;
                   char buffer[16];
                   ssize_t nRead;
                   do {
                       nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
                   } while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));
               } else {
                   ALOGW("Received unexpected epoll event 0x%08x for wake read pipe.",
                           eventItem.events);
               }
               continue;
           }
           ssize_t deviceIndex = mDevices.indexOfKey(eventItem.data.u32);
           if (deviceIndex < 0) {
               ALOGW("Received unexpected epoll event 0x%08x for unknown device id %d.",
                       eventItem.events, eventItem.data.u32);
               continue;
           }
           Device* device = mDevices.valueAt(deviceIndex);
           if (eventItem.events & EPOLLIN) {
                //从device中得到fd后再去读取设备，获取input事件
               int32_t readSize = read(device->fd, readBuffer,
                       sizeof(struct input_event) * capacity);
               if (readSize == 0 || (readSize < 0 && errno == ENODEV)) {
                   // Device was removed before INotify noticed.
                   ALOGW("could not get event, removed? (fd: %d size: %" PRId32
                           " bufferSize: %zu capacity: %zu errno: %d)\n",
                           device->fd, readSize, bufferSize, capacity, errno);
                   deviceChanged = true;
                   closeDeviceLocked(device);
               } else if (readSize < 0) {
                   if (errno != EAGAIN && errno != EINTR) {
                       ALOGW("could not get event (errno=%d)", errno);
                   }
               } else if ((readSize % sizeof(struct input_event)) != 0) {
                   ALOGE("could not get event (wrong size: %d)", readSize);
               } else {
                   int32_t deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;
                   size_t count = size_t(readSize) / sizeof(struct input_event);
                   for (size_t i = 0; i < count; i++) {
                       struct input_event& iev = readBuffer[i];
                       ALOGV("%s got: time=%d.%06d, type=%d, code=%d, value=%d",
                               device->path.string(),
                               (int) iev.time.tv_sec, (int) iev.time.tv_usec,
                               iev.type, iev.code, iev.value);
                       // Some input devices may have a better concept of the time
                       // when an input event was actually generated than the kernel
                       // which simply timestamps all events on entry to evdev.
                       // This is a custom Android extension of the input protocol
                       // mainly intended for use with uinput based device drivers.
                       if (iev.type == EV_MSC) {
                           if (iev.code == MSC_ANDROID_TIME_SEC) {
                               device->timestampOverrideSec = iev.value;
                               continue;
                           } else if (iev.code == MSC_ANDROID_TIME_USEC) {
                               device->timestampOverrideUsec = iev.value;
                               continue;
                           }
                       }
                       if (device->timestampOverrideSec || device->timestampOverrideUsec) {
                           iev.time.tv_sec = device->timestampOverrideSec;
                           iev.time.tv_usec = device->timestampOverrideUsec;
                           if (iev.type == EV_SYN && iev.code == SYN_REPORT) {
                               device->timestampOverrideSec = 0;
                               device->timestampOverrideUsec = 0;
                           }
                           ALOGV("applied override time %d.%06d",
                                   int(iev.time.tv_sec), int(iev.time.tv_usec));
                       }
                       // Use the time specified in the event instead of the current time
                       // so that downstream code can get more accurate estimates of
                       // event dispatch latency from the time the event is enqueued onto
                       // the evdev client buffer.
                       //
                       // The event's timestamp fortuitously uses the same monotonic clock
                       // time base as the rest of Android.  The kernel event device driver
                       // (drivers/input/evdev.c) obtains timestamps using ktime_get_ts().
                       // The systemTime(SYSTEM_TIME_MONOTONIC) function we use everywhere
                       // calls clock_gettime(CLOCK_MONOTONIC) which is implemented as a
                       // system call that also queries ktime_get_ts().
                       event->when = nsecs_t(iev.time.tv_sec) * 1000000000LL
                               + nsecs_t(iev.time.tv_usec) * 1000LL;
                       ALOGV("event time %" PRId64 ", now %" PRId64, event->when, now);
                       // Bug 7291243: Add a guard in case the kernel generates timestamps
                       // that appear to be far into the future because they were generated
                       // using the wrong clock source.
                       //
                       // This can happen because when the input device is initially opened
                       // it has a default clock source of CLOCK_REALTIME.  Any input events
                       // enqueued right after the device is opened will have timestamps
                       // generated using CLOCK_REALTIME.  We later set the clock source
                       // to CLOCK_MONOTONIC but it is already too late.
                       //
                       // Invalid input event timestamps can result in ANRs, crashes and
                       // and other issues that are hard to track down.  We must not let them
                       // propagate through the system.
                       //
                       // Log a warning so that we notice the problem and recover gracefully.
                       if (event->when >= now + 10 * 1000000000LL) {
                           // Double-check.  Time may have moved on.
                           nsecs_t time = systemTime(SYSTEM_TIME_MONOTONIC);
                           if (event->when > time) {
                               ALOGW("An input event from %s has a timestamp that appears to "
                                       "have been generated using the wrong clock source "
                                       "(expected CLOCK_MONOTONIC): "
                                       "event time %" PRId64 ", current time %" PRId64
                                       ", call time %" PRId64 ".  "
                                       "Using current time instead.",
                                       device->path.string(), event->when, time, now);
                               event->when = time;
                           } else {
                               ALOGV("Event time is ok but failed the fast path and required "
                                       "an extra call to systemTime: "
                                       "event time %" PRId64 ", current time %" PRId64
                                       ", call time %" PRId64 ".",
                                       event->when, time, now);
                           }
                       }
                       event->deviceId = deviceId;
                       event->type = iev.type;
                       event->code = iev.code;
                       event->value = iev.value;
                       event += 1;
                       capacity -= 1;
                   }
                   if (capacity == 0) {
                       // The result buffer is full.  Reset the pending event index
                       // so we will try to read the device again on the next iteration.
                       mPendingEventIndex -= 1;
                       break;
                   }
               }
           } else if (eventItem.events & EPOLLHUP) {
               ALOGI("Removing device %s due to epoll hang-up event.",
                       device->identifier.name.string());
               deviceChanged = true;
               closeDeviceLocked(device);
           } else {
               ALOGW("Received unexpected epoll event 0x%08x for device %s.",
                       eventItem.events, device->identifier.name.string());
           }
       }
       // readNotify() will modify the list of devices so this must be done after
       // processing all other events to ensure that we read all remaining events
       // before closing the devices.
       if (mPendingINotify && mPendingEventIndex >= mPendingEventCount) {
           mPendingINotify = false;
           readNotifyLocked();
           deviceChanged = true;
       }
       // Report added or removed devices immediately.
       if (deviceChanged) {
           continue;
       }
       // 如果此次getEvents()调用成功获取了一些事件，或者要求唤醒InputReader，则退出循环并
       // 结束getEvents()的调用，使InputReader可以立刻对事件进行处理
       if (event != buffer || awoken) {
           break;
       }
       /*  如果此次getEvents()调用没能获取事件，说明mPendingEventItems中没有事件可用， */
		/* 于是执行epoll_wait()函数等待新的事件到来，将结果存储到mPendingEventItems里，并重 */
		/* 置mPendingEventIndex为0 */
       mPendingEventIndex = 0;
       mLock.unlock(); // release lock before poll, must be before release_wake_lock
       release_wake_lock(WAKE_LOCK_ID);
      //等待input事件
       int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);
       acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);
       mLock.lock(); // reacquire lock after poll, must be after acquire_wake_lock
       if (pollResult == 0) {
           // Timed out.
           mPendingEventCount = 0;
           break;
       }
       if (pollResult < 0) {
           // An error occurred.
           mPendingEventCount = 0;
           // Sleep after errors to avoid locking up the system.
           // Hopefully the error is transient.
           if (errno != EINTR) {
               ALOGW("poll failed (errno=%d)\n", errno);
               usleep(100000);
           }
       } else {
           // Some events occurred.
           mPendingEventCount = size_t(pollResult);
       }
   }
   // All done, return the number of events we read.
   return event - buffer;
}
```

#### 2.2 打开设备并注册到epoll

```
EventHub.cpp–>EventHub::openDeviceLocked()

status_t EventHub::openDeviceLocked(const char*devicePath) {
	// 打开设备节点的文件描述符，用于获取设备信息以及读取原始输入事件
	int fd =open(devicePath, O_RDWR | O_CLOEXEC);
	// 接下来的代码通过ioctl()函数从设备节点中获取输入设备的厂商信息
	InputDeviceIdentifier identifier;
	......
	// 分配一个设备Id并创建Device结构体
	int32_tdeviceId = mNextDeviceId++;
	Device*device = new Device(fd, deviceId, String8(devicePath), identifier);
	// 为此设备加载配置信息。
	loadConfigurationLocked(device);
	// ① 通过ioctl函数获取设备的事件位掩码。事件位掩码指定了输入设备可以产生何种类型的输入事件
	ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(device->keyBitmask)),device->keyBitmask);
	......
	ioctl(fd, EVIOCGPROP(sizeof(device->propBitmask)),device->propBitmask);
	// 接下来的一大段内容是根据事件位掩码为设备分配类别，即设置classes字段。、
	......
	/* ② 将设备节点的描述符的可读事件注册到Epoll中。当此设备的输入事件到来时，Epoll会在
	getEvents()函数的调用中产生一条epoll事件 */
	struct epoll_event eventItem;
	memset(&eventItem, 0, sizeof(eventItem));
	eventItem.events = EPOLLIN;
	eventItem.data.u32 = deviceId; //注意，epoll_event的自定义信息是设备的Id
	if(epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &eventItem)) {
	......
	}
	......
	// ③ 调用addDeviceLocked()将Device添加到mDevices字典中
	addDeviceLocked(device);
	return 0;
}

```



## 三.InputDisPatcher和窗口通信

#### 3.1  ActivityThread 间接创建RootViewImpl

```
frameworks/base/core/java/android/app/ActivityThread.java

public final class ActivityThread {
    ......
    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume) {
        ......
        // TODO Push resumeArgs into the activity for consideration
        ActivityClientRecord r = performResumeActivity(token, clearHide);

        if (r != null) {
            final Activity a = r.activity;
            ......
            if (r.window == null && !a.mFinished && willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                // 设置 DecorView 为不可见
                decor.setVisibility(View.INVISIBLE);
                // 获取 WindowManager 对象
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (a.mVisibleFromClient) {
                    a.mWindowAdded = true;
                    // 将 DecorView 添加到 ViewManager
                    wm.addView(decor, l);
                }

            } else if (!willBeVisible) {
                ......
            }

            ......

            // 告诉活动管理器我们已经恢复。
            if (reallyResume) {
                try {
                    ActivityManagerNative.getDefault().activityResumed(token);
                } catch (RemoteException ex) {
                }
            }

        } else {
            ......
        }
    }
    ......
}
```

wm 局部变量实际指向 WindowManagerImpl 对象，实际调用了 WindowManagerImpl 类的 addView 方法。此处有调用了 WindowManagerGlobal 单例的 addView 方法

```
frameworks/base/core/java/android/view/WindowManagerImpl.java

public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    ......
    @Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        //创建 ViewRootImpl 对象 调用 ViewRootImpl 类 setView 方法。      
        mGlobal.addView(view, params, mDisplay, mParentWindow);
    }
    ......
}

frameworks/base/core/java/android/view/WindowManagerImpl.java

public final class WindowManagerGlobal {
    ......
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
        ......
        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) {
            ......
            root = new ViewRootImpl(view.getContext(), display);
            ......
        }

        try {
            root.setView(view, wparams, panelParentView);
        } catch (RuntimeException e) {
            ......
        }
    }
    ......
}
```

 ViewRootImpl 完成以下操作

创建 InputChannel 对象，会被保存到mClientChannel

远程调用 Session addToDisplay 方法；创建接收输入事件者 WindowInputEventReceiver。

#### 3.2 注册双端channel和初始化stage

```
frameworks/base/core/java/android/view/ViewRootImpl.java

public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    synchronized (this) {
      ...
      if ((mWindowAttributes.inputFeatures
          & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
          mInputChannel = new InputChannel(); //创建客户端的InputChannel对象
      }
      //通过Binder调用，进入system_server进程的 Session
      res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                  getHostVisibility(), mDisplay.getDisplayId(),
                  mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                  mAttachInfo.mOutsets, mInputChannel);//这里将客户端的InputChannel对象作为参数传入
      ...
      if (mInputChannel != null) {
          if (mInputQueueCallback != null) {
              mInputQueue = new InputQueue();
              mInputQueueCallback.onInputQueueCreated(mInputQueue);
          }
          //创建WindowInputEventReceiver对象，用于接收服务端的消息
          mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,
                  Looper.myLooper());
      }
      ...
     mSyntheticInputStage = new SyntheticInputStage();
	InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage); // Acitivity和view处理各种消息。
	InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage,
       "aq:native-post-ime:" + counterSuffix);
	InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
	InputStage imeStage = new ImeInputStage(earlyPostImeStage,
       "aq:ime:" + counterSuffix);
	InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage); //处理输入法
	InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage,
       "aq:native-pre-ime:" + counterSuffix);
	mFirstInputStage = nativePreImeStage;
	mFirstPostImeInputStage = earlyPostImeStage;
    }
}


```



Session 类表示活动的客户端会话。通常，每个与WindowManagerService交互的进程都有一个 Session 对象。

```
frameworks/base/services/core/java/com/android/server/wm/Session.java

final class Session extends IWindowSession.Stub
        implements IBinder.DeathRecipient {
    final WindowManagerService mService;
    ......
    @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel) {
            //addToDisplay 方法实际工作由 WindowManagerService 类 addWindow 方法完成。
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    }
    ......
}

frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java

public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs {
    ......
    final InputMonitor mInputMonitor = new InputMonitor(this);
    ......
    public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            InputChannel outInputChannel) {
        ......
        synchronized(mWindowMap) {
            ......
            final WindowState win = new WindowState(this, session, client, token, parentWindow,
            appOp[0], seq, attrs, viewVisibility, session.mUid,
            session.mCanAddInternalSystemWindow);
            ......
            //注册服务端到InputDisPatcher端
    	    win.openInputChannel(outInputChannel);
    	    ......

            //mUpdateInputWindowsNeeded 设为true
            mInputMonitor.setUpdateInputWindowsNeededLw();
            ......
            // 拿到焦点窗口句柄
            // 更新当前焦点窗口
            if (focusChanged) {
                mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/);
            }
            mInputMonitor.updateInputWindowsLw(false /*force*/);
            ......
        }
        ......
    }
    ......
}



//如下为注册 服务端到InputDisPatcher端

//frameworks/base/services/core/java/com/android/server/wm/WindowState.java

void openInputChannel(InputChannel outInputChannel) {
    ...
    String name = getName();
    //创建一对SocketPair
    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
    mInputChannel = inputChannels[0];   //服务端
    mClientChannel = inputChannels[1]; 
    mInputWindowHandle.inputChannel = inputChannels[0];
    if (outInputChannel != null) {
    	//将socketPair的另外一个FD放在参数OutputChannel里，
        mClientChannel.transferTo(outInputChannel); //客户端
        mClientChannel.dispose();
        mClientChannel = null;
    } else {
        ...
    }
    //mService 为WindowManagerService 
    //mInputManager 为 InputManagerService
    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);
}





//frameworks/base/services/core/java/com/android/server/input/InputManagerService.java

public void registerInputChannel(InputChannel inputChannel,
        InputWindowHandle inputWindowHandle) {
    ...
    nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false);
}

 
 
 
 
//frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

static void nativeRegisterInputChannel(JNIEnv* env, jclass /* clazz */,
        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor) {
    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);

    sp<InputChannel> inputChannel = android_view_InputChannel_getInputChannel(env,
            inputChannelObj);
    ...
    status_t status = im->registerInputChannel(
            env, inputChannel, inputWindowHandle, monitor);
    ...
}




// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp

status_t NativeInputManager::registerInputChannel(JNIEnv* /* env */,
        const sp<InputChannel>& inputChannel,
        const sp<InputWindowHandle>& inputWindowHandle, bool monitor) {
    return mInputManager->getDispatcher()->registerInputChannel(
            inputChannel, inputWindowHandle, monitor);
}




// frameworks/native/services/inputflinger/InputDispatcher.cpp

status_t InputDispatcher::registerInputChannel(const sp<InputChannel>& inputChannel,
        const sp<InputWindowHandle>& inputWindowHandle, bool monitor) {
        ...
        sp<Connection> connection = new Connection(inputChannel, inputWindowHandle, monitor);

        int fd = inputChannel->getFd();
        mConnectionsByFd.add(fd, connection);
        ...

}
```



#### 3.3 更新焦点窗口给Dispatcher找到connection

InputDispatcher::registerInputChannel往mConnectionsByFd添加一个socket连接,那InputDispatcher又是怎样确定事件分发的时候要分发给谁的呢?

```
// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
@Override
public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            InputChannel outInputChannel) {
    ...
    if (focusChanged) {
        mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/);
    }
    mInputMonitor.updateInputWindowsLw(false /*force*/);
    ...
}




// frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java
void updateInputWindowsLw(boolean force) {
    ...
    mUpdateInputForAllWindowsConsumer.updateInputWindows(inDrag);
    ...
}




// frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java
private void updateInputWindows(boolean inDrag) {
    ...
    mService.mInputManager.setInputWindows(mInputWindowHandles, mFocusedInputWindowHandle);
    ...
}



// frameworks/base/services/core/java/com/android/server/input/InputManagerService.java
public void setInputWindows(InputWindowHandle[] windowHandles,
        InputWindowHandle focusedWindowHandle) {
    ...
    nativeSetInputWindows(mPtr, windowHandles);
}




// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp
static void nativeSetInputWindows(JNIEnv* env, jclass /* clazz */,
        jlong ptr, jobjectArray windowHandleObjArray) {
    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);

    im->setInputWindows(env, windowHandleObjArray);
}




// frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp
void NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray) {
    ...
    mInputManager->getDispatcher()->setInputWindows(windowHandles);
    ...
}




// frameworks/native/services/inputflinger/InputDispatcher.cpp
void InputDispatcher::setInputWindows(const Vector<sp<InputWindowHandle> >& inputWindowHandles) {
    ...
    mWindowHandles = inputWindowHandles;

    sp<InputWindowHandle> newFocusedWindowHandle;
    ...
    for (size_t i = 0; i < mWindowHandles.size(); i++) {
        const sp<InputWindowHandle>& windowHandle = mWindowHandles.itemAt(i);
        ...
        if (windowHandle->getInfo()->hasFocus) {
            newFocusedWindowHandle = windowHandle;
        }
        ...
        mFocusedWindowHandle = newFocusedWindowHandle;
    }
    ...
}

```





## 四.客户端接受处理消息并回调

#### 4.1 客户端接收消息

在 3.2 注册双端消息时 创建了WindowInputEventReceiver，构造方法会调用super，在其父类InputEventReceiver的构造方法中会执行nativeInit，最终执行如下代码，即监听客户端fd。

```
frameworks/base/core/java/android/view/InputEventReceiver.java

public InputEventReceiver(InputChannel inputChannel, Looper looper) {
	   ...

        mInputChannel = inputChannel;
        mMessageQueue = looper.getQueue();
        mReceiverPtr = nativeInit(new WeakReference<InputEventReceiver>(this),
                inputChannel, mMessageQueue);

        mCloseGuard.open("dispose");
    }


frameworks/base/core/jni/android_view_InputEventReceiver.cpp

static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak,
        jobject inputChannelObj, jobject messageQueueObj) {
    sp<InputChannel> inputChannel = android_view_InputChannel_getInputChannel(env,
            inputChannelObj);
    if (inputChannel == NULL) {
        jniThrowRuntimeException(env, "InputChannel is not initialized.");
        return 0;
    }

    sp<MessageQueue> messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    if (messageQueue == NULL) {
        jniThrowRuntimeException(env, "MessageQueue is not initialized.");
        return 0;
    }

    **sp<NativeInputEventReceiver> receiver = new NativeInputEventReceiver(env,
            receiverWeak, inputChannel, messageQueue);
    status_t status = receiver->initialize();**
    if (status) {
        String8 message;
        message.appendFormat("Failed to initialize input event receiver.  status=%d", status);
        jniThrowRuntimeException(env, message.string());
        return 0;
    }

    receiver->incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object
    return reinterpret_cast<jlong>(receiver.get());
}



frameworks/base/core/jni/android_view_InputEventReceiver.cpp

status_t NativeInputEventReceiver::initialize() {
    setFdEvents(ALOOPER_EVENT_INPUT);  
    return OK;
}
void NativeInputEventReceiver::setFdEvents(int events) {
  if (mFdEvents != events) {
      mFdEvents = events;
      int fd = mInputConsumer.getChannel()->getFd();
      if (events) {
          //将socket客户端的fd添加到主线程的消息池
          mMessageQueue->getLooper()->addFd(fd, 0, events, this, NULL);
      } else {
          mMessageQueue->getLooper()->removeFd(fd);
      }
  }
}

```

#### 4.2 客户端处理消息

```
frameworks/base/core/jni/android_view_InputEventReceiver.cpp

int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) {
   ...
   if (events & ALOOPER_EVENT_INPUT) {
       JNIEnv* env = AndroidRuntime::getJNIEnv();
       status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); //消费事件
       mMessageQueue->raiseAndClearException(env, "handleReceiveCallback"); //发生错误回调方法
       return status == OK || status == NO_MEMORY ? 1 : 0;
   }
   ...
}
```

进入consumeEvent方法中

```
frameworks/base/core/jni/android_view_InputEventReceiver.cpp

status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) {
   ...
   ScopedLocalRef<jobject> receiverObj(env, NULL);
   bool skipCallbacks = false;
   for (;;) {
       uint32_t seq;
       InputEvent* inputEvent;
       // 读取InputEvent
       status_t status = mInputConsumer.consume(&mInputEventFactory, consumeBatches, frameTime, &seq, &inputEvent);
    ...
           switch (inputEvent->getType()) {
           case AINPUT_EVENT_TYPE_KEY:
               inputEventObj = android_view_KeyEvent_fromNative(env, static_cast<KeyEvent*>(inputEvent));
               break;
           case AINPUT_EVENT_TYPE_MOTION: {
              ...
           }
           if (inputEventObj) {
               // 调用java层的InputEventReceiver.dispachInputEvent()
               env->CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);
               env->DeleteLocalRef(inputEventObj);
           }
       ...
}
```

进入java层的抽象类 InputEventReceiver 

```
frameworks/base/core/java/android/view/InputEventReceiver.java

public abstract class InputEventReceiver {
   private void dispatchInputEvent(int seq, InputEvent event) {
       mSeqMap.put(event.getSequenceNumber(), seq);
       onInputEvent(event);
   }
```

实现类的onInputEvent中执行enqueueInputEvent

```
frameworks/base/core/java/android/view/ViewRootImpl.java

   final class WindowInputEventReceiver extends InputEventReceiver {
       public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) {
           super(inputChannel, looper);
       }
       public void onInputEvent(InputEvent event) {
           enqueueInputEvent(event, this, 0, true);
       }
   }
```

```
frameworks/base/core/java/android/view/ViewRootImpl.java

void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) {
       adjustInputEventForCompatibility(event);
       // 构建一个QueueInputEvent，插入到pending队列尾部
       QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);
       
       QueuedInputEvent last = mPendingInputEventTail;
        if (last == null) {
            mPendingInputEventHead = q;
            mPendingInputEventTail = q;
        } else {
            last.mNext = q;
            mPendingInputEventTail = q;
        }
        mPendingInputEventCount += 1;
        
       // 处理pending队列里的event
       if (processImmediately) {
           doProcessInputEvents();//立刻执行
       } else {
           scheduleProcessInputEvents();//延迟执行
       }
   }
   
   
   void doProcessInputEvents() {
       // Deliver all pending input events in the queue.
       while (mPendingInputEventHead != null) {
           QueuedInputEvent q = mPendingInputEventHead;
           ...
           deliverInputEvent(q);//分发事件
       }
       ...
   }
```

#### 4.3 责任链模式的分发事件

```
frameworks/base/core/java/android/view/ViewRootImpl.java

private void deliverInputEvent(QueuedInputEvent q) {
       ...
       InputStage stage;
       //这里是stage实现类
       if (q.shouldSendToSynthesizer()) {
           stage = mSyntheticInputStage;
       } else {
           stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;
       }
       if (stage != null) {
           stage.deliver(q);
       } else {
           finishInputEvent(q);//完成事件分发处理
       }
   }
```



Activity和View的事件的事件处理InputStage为 ViewPostImeInputStage

```
frameworks/base/core/java/android/view/ViewRootImpl.java

final class ViewPostImeInputStage extends InputStage {
    public ViewPostImeInputStage(InputStage next) {
        super(next);
   }

    @Override
    protected int onProcess(QueuedInputEvent q) {
        if (q.mEvent instanceof KeyEvent) { 
            return processKeyEvent(q); //对于的是按键事件处理
       } else {
            final int source = q.mEvent.getSource();
           if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
                return processPointerEvent(q);  //触摸事件处理
           } else if ((source & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
                return processTrackballEvent(q);//轨迹球事件处理
           } else {
                return processGenericMotionEvent(q);
           }
        }
    }
...
}

```

处理按键消息

```
frameworks/base/core/java/android/view/ViewRootImpl.java

 final class ViewPostImeInputStage extends InputStage
	{
		private int processKeyEvent(QueuedInputEvent q) {
            final KeyEvent event = (KeyEvent)q.mEvent;

            if (mUnhandledKeyManager.preViewDispatch(event)) {
                return FINISH_HANDLED;
            }

            //分发按键事件到视图树，mView即是DecorView
            //DecorView继承FrameLayout,FrameLayout继承ViewGroup，
            // DecorView.dispatchKeyEvent(event)重写了父类ViewGroup.dispatchKeyEvent(event)方法
            // Deliver the key to the view hierarchy.
            if (mView.dispatchKeyEvent(event)) {
                return FINISH_HANDLED;
            }

            if (shouldDropInputEvent(q)) {
                return FINISH_NOT_HANDLED;
            }

            // This dispatch is for windows that don't have a Window.Callback. Otherwise,
            // the Window.Callback usually will have already called this (see
            // DecorView.superDispatchKeyEvent) leaving this call a no-op.
            if (mUnhandledKeyManager.dispatch(mView, event)) {
                return FINISH_HANDLED;
            }

            int groupNavigationDirection = 0;
            if (event.getAction() == KeyEvent.ACTION_DOWN
                    && event.getKeyCode() == KeyEvent.KEYCODE_TAB) {
                if (KeyEvent.metaStateHasModifiers(event.getMetaState(), KeyEvent.META_META_ON)) {
                    groupNavigationDirection = View.FOCUS_FORWARD;
                } else if (KeyEvent.metaStateHasModifiers(event.getMetaState(),
                        KeyEvent.META_META_ON | KeyEvent.META_SHIFT_ON)) {
                    groupNavigationDirection = View.FOCUS_BACKWARD;
                }
            }

            // If a modifier is held, try to interpret the key as a shortcut.
            if (event.getAction() == KeyEvent.ACTION_DOWN
                    && !KeyEvent.metaStateHasNoModifiers(event.getMetaState())
                    && event.getRepeatCount() == 0
                    && !KeyEvent.isModifierKey(event.getKeyCode())
                    && groupNavigationDirection == 0) {
                if (mView.dispatchKeyShortcutEvent(event)) {
                    return FINISH_HANDLED;
                }
                if (shouldDropInputEvent(q)) {
                    return FINISH_NOT_HANDLED;
                }
            }

            // Apply the fallback event policy.
            if (mFallbackEventHandler.dispatchKeyEvent(event)) {
                return FINISH_HANDLED;
            }
            if (shouldDropInputEvent(q)) {
                return FINISH_NOT_HANDLED;
            }

            // Handle automatic focus changes.
            //如果是按键按下事件，则处理焦点自动导航.
            if (event.getAction() == KeyEvent.ACTION_DOWN) {
                if (groupNavigationDirection != 0) {
                    if (performKeyboardGroupNavigation(groupNavigationDirection)) {
                        return FINISH_HANDLED;
                    }
                } else {
                    if (performFocusNavigation(event)) {
                        return FINISH_HANDLED;
                    }
                }
            }
            return FORWARD;
        }
	}
```



```
frameworks/base/core/java/com/android/internal/policy/DecorView.java

 @Override
    public boolean dispatchKeyEvent(KeyEvent event) {
        final int keyCode = event.getKeyCode();
        final int action = event.getAction();
        final boolean isDown = action == KeyEvent.ACTION_DOWN;

        if (isDown && (event.getRepeatCount() == 0)) {
            // First handle chording of panel key: if a panel key is held
            // but not released, try to execute a shortcut in it.
            if ((mWindow.mPanelChordingKey > 0) && (mWindow.mPanelChordingKey != keyCode)) {
                boolean handled = dispatchKeyShortcutEvent(event);
                if (handled) {
                    return true;
                }
            }

            // If a panel is open, perform a shortcut on it without the
            // chorded panel key
            if ((mWindow.mPreparedPanel != null) && mWindow.mPreparedPanel.isOpen) {
                if (mWindow.performPanelShortcut(mWindow.mPreparedPanel, keyCode, event, 0)) {
                    return true;
                }
            }
        }
	 // 当Window没destroy且其Callback非空的话，交给其Callback处理
        if (!mWindow.isDestroyed()) {
            //DecorView中的mWindow唯一实现类就是PhoneWindow，而Activity则是Window.Callback是实现类。Activity中调用mWindow.setCallback(this)
            //故而，此处mWindow.getCallback()获取到的就是Activity实例，实际上就是Activity.dispatchKeyEvent(event)
            
            final Window.Callback cb = mWindow.getCallback();
            final boolean handled = cb != null && mFeatureId < 0 ? cb.dispatchKeyEvent(event)
                    : super.dispatchKeyEvent(event);
            if (handled) {
                return true;
            }
        }
	// 如果上面还没处理，则分发到PhoneWindow到onKeyDown、onKeyUp事件处理
        return isDown ? mWindow.onKeyDown(mFeatureId, event.getKeyCode(), event)
                : mWindow.onKeyUp(mFeatureId, event.getKeyCode(), event);
    }
```

接着到Activity中的方法

```
frameworks/base/core/java/android/app/Activity.java

    public boolean dispatchKeyEvent(KeyEvent event) {
        onUserInteraction();

        //处理KEYCODE_MENU键，Activity有ActionBar且消费该按键
        final int keyCode = event.getKeyCode();
        if (keyCode == KeyEvent.KEYCODE_MENU &&
                mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
            return true;
        }

        Window win = getWindow();
         // 从这里事件的处理交给了与之相关的window对象，实质是派发到了view层次结构
        if (win.superDispatchKeyEvent(event)) {
            return true;
        }
        View decor = mDecor;
        if (decor == null) decor = win.getDecorView();
        // 如果view层次结构没处理则交给KeyEvent本身的dispatch方法，Activity的各种回调方法会被触发
        return event.dispatch(this, decor != null
                ? decor.getKeyDispatcherState() : null, this);
    }
```

先看 Window.superDispatchKeyEvent(event) 这是个抽象方法 其子类PhoneWindow实现了该方法

```
frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java
  
  @Override
    public boolean superDispatchKeyEvent(KeyEvent event) {
        return mDecor.superDispatchKeyEvent(event);
    }
    
```

 该方法又回调用DecorView中的superDispatchKeyEvent方法:

```
frameworks/base/core/java/com/android/internal/policy/DecorView.java

  public boolean superDispatchKeyEvent(KeyEvent event) {
        // Give priority to closing action modes if applicable.
        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
            final int action = event.getAction();
            // Back cancels action modes first.
            if (mPrimaryActionMode != null) {
                if (action == KeyEvent.ACTION_UP) {
                    mPrimaryActionMode.finish();
                }
                return true;
            }
        }

    // 如果 ViewGroup 的dispatchKeyEvent方法消费掉了，返回true不走下面
    if (super.dispatchKeyEvent(event)) {
        return true;
    }

    // 如果ViewRootImpl不为空且被ViewRootImpl的dispatchUnhandledKeyEvent方法消费了，则返回true
    return (getViewRootImpl() != null) && getViewRootImpl().dispatchUnhandledKeyEvent(event);
}
```

以下就进入了ViewGroup及View的分发拦截消费相关。

![img](https://img2020.cnblogs.com/blog/1738903/202008/1738903-20200806145151611-122395595.png)



#### 4.4 责任链最后的回调处理

```
frameworks/base/core/java/android/view/ViewRootImpl.java

private void deliverInputEvent(QueuedInputEvent q) {
       ...
       InputStage stage;
       //这里是stage实现类
       if (q.shouldSendToSynthesizer()) {
           stage = mSyntheticInputStage;
       } else {
           stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;
       }
       if (stage != null) {
           stage.deliver(q);
       } else {
           finishInputEvent(q);//完成事件分发处理
       }
   }
```

进入回调方法

```
frameworks/base/core/java/android/view/ViewRootImpl.java

private void finishInputEvent(QueuedInputEvent q) {
  ...
       q.mReceiver.finishInputEvent(q.mEvent, handled);
   ...
}
```



```
frameworks/base/core/java/android/view/InputEventReceiver.java

public final void finishInputEvent(InputEvent event, boolean handled) {
     ...
           nativeFinishInputEvent(mReceiverPtr, seq, handled);
     ...
}

static void nativeFinishInputEvent(JNIEnv* env, jclass clazz, jlong receiverPtr,
        jint seq, jboolean handled) {
    sp<NativeInputEventReceiver> receiver =
            reinterpret_cast<NativeInputEventReceiver*>(receiverPtr);
    status_t status = receiver->finishInputEvent(seq, handled);
    if (status && status != DEAD_OBJECT) {
        String8 message;
        message.appendFormat("Failed to finish input event.  status=%d", status);
        jniThrowRuntimeException(env, message.string());
    }
}
```



```
frameworks/base/core/jni/android_view_InputEventReceiver.cpp

status_t NativeInputEventReceiver::finishInputEvent(uint32_t seq, bool handled) {
  ... 

    status_t status = mInputConsumer.sendFinishedSignal(seq, handled);
  ...
}
```



```
frameworks/native/libs/input/InputTransport.cpp

status_t InputConsumer::sendFinishedSignal(uint32_t seq, bool handled) {
  ...
   return sendUnchainedFinishedSignal(seq, handled);
}
```



```
status_t InputConsumer::sendUnchainedFinishedSignal(uint32_t seq, bool handled) {
    InputMessage msg;
    msg.header.type = InputMessage::TYPE_FINISHED;
    msg.body.finished.seq = seq;
    msg.body.finished.handled = handled;
    return mChannel->sendMessage(&msg);
}
```

通过InputChannel 发送完成的message, 服务端收到消息后回调InputDispatcher.handleReceiveCallback()，最终会调用doDispatchCycleFinishedLockedInterruptible()方法 ,将dispatchEntry事件从等待队列(waitQueue)中移除。